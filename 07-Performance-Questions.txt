================================================================================
РАЗДЕЛ 7: ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ
================================================================================

ВОПРОС 1: Что такое Virtual DOM в React и как он улучшает производительность?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Virtual DOM - это представление реального DOM в памяти JavaScript как обычный
объект. React использует его для оптимизации обновлений страницы.

КАК ЭТО РАБОТАЕТ:

1. РЕНДЕРИНГ КОМПОНЕНТА
React создает Virtual DOM представление компонента (обычный JavaScript объект).

2. СРАВНЕНИЕ (diffing)
Когда состояние изменяется, React:
• Создает новый Virtual DOM
• Сравнивает его со старым Virtual DOM
• Находит различия (что изменилось)

3. ОБНОВЛЕНИЕ (patching)
React обновляет ТОЛЬКО реальный DOM части, которые изменились.

ПРИМЕР:

Представьте, что у вас есть список из 1000 пользователей и вы добавляете одного нового.

БЕЗ VIRTUAL DOM (обновляем весь DOM):
Удалить все 1000+ элементов
Создать все 1000+ элементов заново
Это медленно!

С VIRTUAL DOM (обновляем только новый элемент):
Определить, что добавился только один элемент
Добавить только этот один элемент в реальный DOM
Это быстро!

АЛГОРИТМ СРАВНЕНИЯ:

React использует эффективный алгоритм для сравнения Virtual DOM деревьев:

1. Если элемент другого типа, заменить весь элемент
2. Если элемент того же типа, сравнить атрибуты
3. Если атрибут key есть, использовать его для отображения

ПРИМЕР СРАВНЕНИЯ:

Старый Virtual DOM:
<ul>
  <li key="1">Яблоко</li>
  <li key="2">Груша</li>
</ul>

Новый Virtual DOM:
<ul>
  <li key="1">Яблоко</li>
  <li key="2">Груша</li>
  <li key="3">Апельсин</li>
</ul>

React определит:
• li с key="1" не изменился
• li с key="2" не изменился
• li с key="3" новый - добавить его в реальный DOM

ПОЧЕМУ VIRTUAL DOM БЫСТРЕЕ:

1. ПАКЕТНЫЕ ОБНОВЛЕНИЯ
React группирует несколько изменений и применяет их за один раз.

2. МИНИМАЛЬНЫЕ ИЗМЕНЕНИЯ РЕАЛЬНОГО DOM
Работа с реальным DOM дорогостояща (медленно).
Virtual DOM позволяет рассчитать минимум изменений перед обновлением.

3. ИЗ��ЕГАЕМ ПЕРЕРИСОВОК
Браузер должен перерасчитать стили и переорисовать при изменении DOM.
Virtual DOM уменьшает количество таких операций.

СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ:

Операция: Добавить элемент к списку из 100 элементов

Чистый JavaScript (прямое манипулирование DOM):
• Найти контейнер: O(1)
• Создать элемент: O(1)
• Добавить в DOM: O(1)
• Браузер перерисует: O(n) где n = 100+

jQuery (упрощенное DOM манипулирование):
• То же, что выше

React (с Virtual DOM):
• Создать Virtual DOM: O(n) где n = 100
• Сравнить: O(n)
• Обновить реальный DOM: O(1)
• Браузер перерисует: O(1)

Результат: React быстрее когда мало изменений!

ОГРАНИЧЕНИЯ VIRTUAL DOM:

Не всегда Virtual DOM быстрее. Если:
• Много элементов меняется
• Сложное дерево компонентов
То сравнение тоже дорого.

================================================================================

ВОПРОС 2: Как оптимизировать React компоненты?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Оптимизация React компонентов - это избежание ненужных рендеринговп компонентов.

ТЕХНИКА 1: React.memo - мемоизация компонентов

function MyComponent({ name }) {
  console.log("MyComponent рендерится");
  return <div>{name}</div>;
}

export default React.memo(MyComponent);

React.memo предотвращает рендеринг если пропсы не изменились:

function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
      <MyComponent name="Иван" />  {/* не будет перерисовываться */}
    </div>
  );
}

При клике на кнопку:
• App компонент перерисуется
• MyComponent НЕ будет перерисован (пропсы не изменились)

ТЕХНИКА 2: useCallback - мемоизация функций

Проблема: каждый рендеринг создает новую функцию

function Parent() {
  const [count, setCount] = useState(0);
  
  // Каждый рендеринг создает новую функцию!
  const handleClick = () => {
    console.log("Нажата кнопка");
  };
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
      <Child onClick={handleClick} />  {/* Child будет перерисован! */}
    </div>
  );
}

Решение: useCallback

function Parent() {
  const [count, setCount] = useState(0);
  
  // Функция создается один раз и переиспользуется
  const handleClick = useCallback(() => {
    console.log("Нажата кнопка");
  }, []);  // пусто = зависимостей нет
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
      <Child onClick={handleClick} />  {/* Child НЕ будет перерисован */}
    </div>
  );
}

ТЕХНИКА 3: useMemo - мемоизация вычислений

Проблема: дорогие вычисления выполняются при каждом рендеринге

function UserList({ users, searchQuery }) {
  // Это вычисляется при КАЖДОМ рендеринге
  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  return (
    <ul>
      {filteredUsers.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

Решение: useMemo

function UserList({ users, searchQuery }) {
  // Вычисляется только если users или searchQuery изменились
  const filteredUsers = useMemo(() => {
    return users.filter(user =>
      user.name.toLowerCase().includes(searchQuery.toLowerCase())
    );
  }, [users, searchQuery]);  // зависимости
  
  return (
    <ul>
      {filteredUsers.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

ТЕХНИКА 4: Разбить компоненты на части

Проблема: большой компонент с много состояний

function Dashboard() {
  const [users, setUsers] = useState([]);
  const [posts, setPosts] = useState([]);
  const [comments, setComments] = useState([]);
  // еще много состояний...
  
  return (
    <div>
      <UserList users={users} />
      <PostList posts={posts} />
      <CommentList comments={comments} />
    </div>
  );
}

Когда любое состояние меняется, весь Dashboard перерисуется!

Решение: разделить на отдельные компоненты

function UserSection({ users }) {
  return <UserList users={users} />;
}

function PostSection({ posts }) {
  return <PostList posts={posts} />;
}

function Dashboard() {
  const [users, setUsers] = useState([]);
  const [posts, setPosts] = useState([]);
  
  return (
    <div>
      <UserSection users={users} />
      <PostSection posts={posts} />
    </div>
  );
}

Теперь когда users меняется, только UserSection перерисуется.

ТЕХНИКА 5: Отложенное состояние (lazy state)

Используйте код разделение (code splitting) для загрузки компонентов по требованию.

Было:
import HeavyComponent from './HeavyComponent';

function App() {
  return <HeavyComponent />;
}

Стало:
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<p>Загрузка...</p>}>
      <HeavyComponent />
    </Suspense>
  );
}

HeavyComponent будет загружен только когда он действительно нужен.

СРАВНЕНИЕ ОПТИМИЗАЦИЙ:

┌──────────────┬─────────────────┬──────────────┐
│ Техника      │ Использование   │ Вес кода     │
├──────────────┼─────────────────┼──────────────┤
│ React.memo   │ Простые компоненты│ +3 строки  │
│ useCallback  │ Передача функций  │ +2 строки  │
│ useMemo      │ Дорогие вычисления│ +2 строки  │
│ Разделение   │ Большие приложения│ средний     │
│ Code splitting│ Тяжелые компоненты│ средний    │
└──────────────┴────��────────────┴──────────────┘

КОГДА ОПТИМИЗИРОВАТЬ:

1. Сначала напишите рабочий код
2. Измерьте производительность (React DevTools Profiler)
3. Найдите узкие места
4. Оптимизируйте только их
5. Измерьте снова

Не оптимизируйте без измерений - можете сделать только хуже!

================================================================================

ВОПРОС 3: Что такое асинхронное программирование в React и как с ним работать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

В React часто нужно загружать данные с сервера и управлять этим процессом
в компонентах. Это асинхронное программирование.

ЗАГРУЗКА ДАННЫХ - ПРАВИЛЬНЫЙ СПОСОБ:

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Выполняется при монтировании компонента
    setLoading(true);
    
    fetch(`/api/users/${userId}`)
      .then(response => {
        if (!response.ok) throw new Error("Ошибка при загрузке");
        return response.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);  // зависимость: перезагрузить если userId изменился
  
  if (loading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error}</p>;
  if (!user) return <p>Пользователь не найден</p>;
  
  return <h1>{user.name}</h1>;
}

ТОТ ЖЕ ПРИМЕР С ASYNC/AWAIT:

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Создаем отдельную async функцию
    async function fetchUser() {
      try {
        setLoading(true);
        
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error("Ошибка при загрузке");
        
        const data = await response.json();
        setUser(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    // Вызываем async функцию
    fetchUser();
  }, [userId]);
  
  if (loading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error}</p>;
  if (!user) return <p>Пользователь не найден</p>;
  
  return <h1>{user.name}</h1>;
}

ВАЖНО: Не можно делать саму useEffect async функцией!

НЕПРАВИЛЬНО:
useEffect(async () => {  // неправильно!
  const data = await fetch(...);
}, []);

ПРАВИЛЬНО:
useEffect(() => {
  async function fetchData() {
    const data = await fetch(...);
  }
  fetchData();
}, []);

ОТМЕНА ЗАПРОСОВ:

Проблема: если компонент размонтируется, а запрос еще не закончился,
может быть ошибка "Cannot set state on unmounted component".

Решение: используйте AbortController

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const controller = new AbortController();
    
    fetch(`/api/users/${userId}`, {
      signal: controller.signal
    })
      .then(res => res.json())
      .then(data => setUser(data))
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error("Ошибка:", err);
        }
      });
    
    // Очистка: отменяем запрос при размонтировании
    return () => controller.abort();
  }, [userId]);
  
  return <h1>{user?.name}</h1>;
}

================================================================================

ВОПРОС 4: Какие инструменты для профилирования и отладки используются в React?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Для поиска проблем производительности React предоставляет встроенные инструменты.

ИНСТРУМЕНТ 1: React DevTools

Это расширение браузера, которое позволяет:
• Инспектировать компоненты
• Просмотреть пропсы и состояние
• Профилировать компоненты
• Отследить обновления

Установка:
1. Chrome: React Developer Tools в Chrome Web Store
2. Firefox: React Developer Tools в Firefox Add-ons

Использование:
1. Откройте DevTools (F12)
2. Перейдите на вкладку "Components"
3. Выберите компонент в дереве
4. Посмотрите пропсы и состояние справа

ИНСТРУМЕНТ 2: React Profiler

Встроенный профайлер для измерения производительности.

Как использовать:

import { Profiler } from 'react';

function onRenderCallback(
  id,           // id компонента
  phase,        // "mount" или "update"
  actualDuration, // время рендеринга в мс
  baseDuration,   // время без мемоизации
  startTime,      // когда начался рендеринг
  commitTime,     // когда закончился рендеринг
  interactions    // interactions
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <MyComponent />
    </Profiler>
  );
}

ИНСТРУМЕНТ 3: React DevTools Profiler (вкладка Profiler)

1. Откройте React DevTools → Profiler
2. Нажмите красный круг (начать запись)
3. Выполните действия, которые хотите профилировать
4. Нажмите красный круг снова (закончить запись)

Результат:
• Какие компоненты рендерились
• Сколько времени потратили
• Какой компонент медленный

ИНСТРУМЕНТ 4: Chrome DevTools Performance

Для более глубокого анализа работы браузера:

1. Откройте Chrome DevTools → Performance
2. Нажмите "Record"
3. Выполните действие
4. Нажмите "Stop"

Результат:
• Временная шкала всех операций
• JavaScript выполнение
• Рендеринг браузера
• Макет обновления

ИНСТРУМЕНТ 5: console.log для отладки

Простой способ отследить что происходит:

function MyComponent({ name }) {
  console.log("MyComponent рендерится с name=" + name);
  
  useEffect(() => {
    console.log("Компонент смонтирован");
    
    return () => {
      console.log("Компонент размонтирован");
    };
  }, []);
  
  return <div>{name}</div>;
}

ИНСТРУМЕНТ 6: Custom Hooks для логирования

function useLogger(message) {
  console.log(message);
  
  useEffect(() => {
    console.log(message + " - смонтирован");
    
    return () => {
      console.log(message + " - размонтирован");
    };
  }, [message]);
}

// Использование:
function MyComponent() {
  useLogger("MyComponent");
  return <div>...</div>;
}

================================================================================