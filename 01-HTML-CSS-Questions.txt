================================================================================
РАЗДЕЛ 1: HTML И CSS
================================================================================

ВОПРОС 1: Что такое семантический HTML и почему он важен?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Семантический HTML - это использование HTML тегов, которые имеют смысловое
значение. То есть, тег не просто оформляет текст визуально, а передает
информацию о том, ЧТО это за содержимое.

Примеры семантических тегов:
• <header> - для заголовка страницы или раздела
• <nav> - для навигации
• <main> - для основного содержимого
• <article> - для статьи или независимого контента
• <section> - для раздела документа
• <aside> - для боковой информации
• <footer> - для подвала страницы
• <figure> и <figcaption> - для изображений с описанием

Примеры несемантических тегов:
• <div> - просто контейнер без смысла
• <span> - просто встроенный элемент без смысла

ПОЧЕМУ ЭТО ВАЖНО?

1. SEO (поисковая оптимизация): Поисковые системы лучше понимают структуру
   вашей страницы, когда используются правильные теги. Это помогает сайту
   лучше ранжироваться в результатах поиска.

2. Доступность: Люди с нарушениями зрения используют скринридеры (программы,
   которые читают текст вслух). Семантический HTML помогает им лучше по��ять
   структуру страницы.

3. Поддерживаемость кода: Другие разработчики (или вы сами через время)
   быстрее разберут структуру вашего кода.

4. Мобильные и устаревшие браузеры: Семантические теги работают надежнее
   на разных устройствах.

ПРИМЕР ПЛОХОГО КОДА (несемантический):

<div id="header">
  <div id="nav">
    <div><a href="/">Главная</a></div>
    <div><a href="/about">О нас</a></div>
  </div>
</div>

<div id="main">
  <div>Это статья...</div>
</div>

ПРИМЕР ХОРОШЕГО КОДА (семантический):

<header>
  <nav>
    <a href="/">Главная</a>
    <a href="/about">О нас</a>
  </nav>
</header>

<main>
  <article>Это статья...</article>
</main>

================================================================================

ВОПРОС 2: Что такое CSS Grid и как он отличается от Flexbox?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

CSS Grid и Flexbox - это два современных способа создания макетов в CSS.
Оба позволяют выравнивать элементы, но работают немного по-разному.

FLEXBOX (одномерная раскладка):

Flexbox раскладывает элементы в одну линию (горизонтально или вертикально).
Он хорош для простых раскладок в одном направлении.

Основные свойства:
• display: flex - включает режим flexbox для контейнера
• flex-direction: row | column - направление (строка или колонка)
• justify-content - выравнивание по главной оси
• align-items - выравнивание по вспомогательной оси
• flex: 1 - для элементов, чтобы они распределяли пространство поровну

ПРИМЕР FLEXBOX:

<style>
  .container {
    display: flex;
    gap: 10px; /* расстояние между элементами */
  }
  
  .item {
    flex: 1; /* каждый элемент занимает равную часть */
  }
</style>

<div class="container">
  <div class="item">Элемент 1</div>
  <div class="item">Элемент 2</div>
  <div class="item">Элемент 3</div>
</div>

Результат: три элемента в один ряд, поровну распределяющие ширину.

CSS GRID (двумерная раскладка):

Grid раскладывает элементы в таблицу (с рядами и колонками одновременно).
Он мощнее и универсальнее, когда нужна двумерная раскладка.

Основные свойства:
• display: grid - включает режим grid для контейнера
• grid-template-columns - определение ширины колонок
• grid-template-rows - определение высоты рядов
• gap - расстояние между ячейками
• grid-column и grid-row - для позиционирования элементов в сетке

ПРИМЕР CSS GRID:

<style>
  .container {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr; /* три колонки одинаковой ширины */
    grid-template-rows: 100px 100px; /* два ряда высотой 100px */
    gap: 10px;
  }
</style>

<div class="container">
  <div>Ячейка 1</div>
  <div>Ячейка 2</div>
  <div>Ячейка 3</div>
  <div>Ячейка 4</div>
  <div>Ячейка 5</div>
  <div>Ячейка 6</div>
</div>

Результат: таблица 3x2 (3 колонки, 2 ряда).

КОГДА ИСПОЛЬЗОВАТЬ?

FLEXBOX когда:
• Нужно расположить элементы в одну строку или столбец
• Элементы должны быть гибкими и выравниваться вдоль одной оси
• Простой навигационный стол, кнопки рядом и т.д.

GRID когда:
• Нужна сложная двумерная раскладка
• Есть заголовок, боковая панель, основное содержимое и подвал
• Нужна таблица-подобная раскла��ка
• Элементы должны выравниваться одновременно по рядам И колонкам

ОТЛИЧИЯ В ТАБЛИЦЕ:

┌─────────────┬──────────────────┬──────────────────┐
│ Свойство    │ Flexbox           │ Grid             │
├─────────────┼──────────────────┼──────────────────┤
│ Направление │ 1D (одномерный)   │ 2D (двумерный)   │
│ Сложность   │ Простой           │ Более мощный     │
│ Использование│ Компоненты       │ Весь макет       │
└─────────────┴──────────────────┴──────────────────┘

================================================================================

ВОПРОС 3: Что такое медиа-запросы (media queries) и как их использовать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Медиа-запросы - это CSS инструмент, который позволяет применять разные с��или
в зависимости от параметров устройства (размер экрана, ориентация, 
разрешение и т.д.).

Другими словами, это способ сделать сайт адаптивным (responsive), чтобы он
хорошо выглядел на телефонах, планшетах и компьютерах.

СИНТАКСИС:

@media (условие) {
  /* CSS стили, которые применятся, если условие выполнено */
}

ОСНОВНЫЕ УСЛОВИЯ:

1. max-width - применить стили, если ширина экрана МЕНЬШЕ ИЛИ РАВНА значению
2. min-width - применить стили, если ширина экрана БОЛЬШЕ ИЛИ РАВНА значению
3. orientation - проверить ориентацию (portrait - вертикально, landscape - горизонтально)

ПРИМЕР 1: Адаптивный дизайн для мобильных и компьютеров

<style>
  /* Стили для компьютеров (экран больше 768px) */
  .container {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr; /* 3 колонки */
    font-size: 16px;
  }
  
  /* Стили для планшетов и малых экранов (экран меньше 768px) */
  @media (max-width: 768px) {
    .container {
      grid-template-columns: 1fr 1fr; /* 2 колонки */
      font-size: 14px;
    }
  }
  
  /* Стили для мобильных телефонов (экран меньше 480px) */
  @media (max-width: 480px) {
    .container {
      grid-template-columns: 1fr; /* 1 колонка */
      font-size: 12px;
    }
  }
</style>

ПРИМЕР 2: Скрыть элемент на мобильных устройствах

@media (max-width: 768px) {
  .sidebar {
    display: none; /* скрыть боковую панель на мобильных */
  }
}

ПРИМЕР 3: Изменить ориентацию

@media (orientation: portrait) {
  /* стили для вертикальной ориентации */
}

@media (orientation: landscape) {
  /* стили для горизонтальной ориентации */
}

РАСПРОСТРАНЕННЫЕ ТОЧКИ РАЗРЫВА (breakpoints):

Это стандартные размеры экранов, для которых часто создают отдельные стили:

• 480px - маленькие смартфоны (iPhone SE)
• 768px - планшеты (iPad)
• 1024px - большие планшеты и маленькие ноутбуки
• 1440px - стандартные мониторы
• 1920px - большие мониторы
• 2560px - очень большие экраны (4K)

ЛУЧШИЕ ПРАКТИКИ:

1. Сначала пишите стили для мобильных (mobile-first подход), потом увеличивайте

@media (min-width: 768px) {
  /* стили для более больших экранов */
}

2. Используйте относительные единицы (%, em, rem) вместо фиксированных (px)

3. Тестируйте на реальных устройствах, а не только в браузере

4. Избегайте слишком много точек разрыва (2-4 достаточно)

================================================================================

ВОПРОС 4: Что такое CSS-препроцессоры (SASS, LESS) и зачем они нужн��?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

CSS-препроцессоры - это инструменты, которые расширяют возможности CSS,
добавляя программные конструкции. Вы пишете код на SASS или LESS, а затем
он компилируется в обычный CSS, который браузер может понять.

ОСНОВНЫЕ CSS-ПРЕПРОЦЕССОРЫ:

1. SASS (Syntactically Awesome Stylesheets) - самый популярный
2. LESS - похож на SASS, но проще
3. Stylus - мало используется

ОСНОВНЫЕ ВОЗМОЖНОСТИ:

1. ПЕРЕМЕННЫЕ - сохранять повторяющиеся значения

ПРИМЕР SASS:

$primary-color: #3498db;
$border-radius: 4px;

.button {
  background-color: $primary-color;
  border-radius: $border-radius;
}

.alert {
  color: $primary-color;
  border-radius: $border-radius;
}

// После компиляции превращается в обычный CSS:
// .button { background-color: #3498db; border-radius: 4px; }
// .alert { color: #3498db; border-radius: 4px; }

Преимущество: если вы измените цвет, он изменится везде.

2. ВЛОЖЕННОСТЬ - организовать код иерархией

ПРИМЕР SASS:

.navbar {
  background: #333;
  
  .logo {
    font-size: 24px;
    color: white;
  }
  
  .menu {
    list-style: none;
    
    li {
      display: inline;
      margin-right: 20px;
    }
    
    a {
      color: white;
      text-decoration: none;
      
      &:hover {
        color: #3498db;
      }
    }
  }
}

// После компиляции:
// .navbar { background: #333; }
// .navbar .logo { font-size: 24px; color: white; }
// .navbar .menu { list-style: none; }
// .navbar .menu li { display: inline; margin-right: 20px; }
// .navbar .menu a { color: white; text-decoration: none; }
// .navbar .menu a:hover { color: #3498db; }

& означает текущий селектор (в примере выше & = .navbar a)

3. МИКСИНЫ - переиспользуемые блоки CSS

ПРИМЕР SASS:

@mixin flexbox-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.hero {
  @include flexbox-center;
  height: 500px;
}

.modal {
  @include flexbox-center;
  width: 400px;
}

// После компиляции оба класса получат флексбокс код

4. ФУНКЦИИ - вычисляют значения

ПРИМЕР SASS:

$base-font-size: 16px;

@function rem($pixels) {
  @return $pixels / 16 * 1rem;
}

.heading {
  font-size: rem(24);  // результат: 1.5rem
}

5. ИМПОРТ ФАЙЛОВ - разделять код на части

ПРИМЕР:

// main.scss
@import 'variables'; // импортирует _variables.scss
@import 'mixins';    // импортирует _mixins.scss
@import 'buttons';   // импортирует _buttons.scss

Это намного удобнее, чем писать все в одном большом файле CSS.

СИНТАКСИС SASS - ДВА ВАРИАНТА:

1. SCSS синтаксис (более новый и популярный) - выглядит как CSS:

$color: red;
.button { color: $color; }

2. INDENTED синтаксис (старый) - использует отступы вместо скобок:

$color: red
.button
  color: $color

ЗАЧЕМ ЭТО НУЖНО?

Без препроцессоров:
• Много повторений (один цвет написан в 20 местах)
• Сложная организация (один большой файл на 5000 строк)
• Нет переменных и функций
• Трудно поддерживать и изменять

С препроцессорами:
• Переменные - измените один раз, изменится везде
• Вложенность - понятная структура
• Миксины - переиспользуемые куски кода
• Легче поддерживать и расширять

ПРОЦЕСС КОМПИЛЯЦИИ:

1. Вы пишете в SASS файле (style.scss)
2. Компилятор преобразует его в обычный CSS (style.css)
3. В HTML вы подключаете .css файл

Компилятор можно запустить:
• Вручную через командную строку
• Автоматически с помощью сборщика (Webpack, Gulp, Parcel и т.д.)

================================================================================

ВОПРОС 5: Что такое BEM методология в CSS и как её использовать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

BEM - это методология наименования CSS классов. Это способ организации и
названия ваших классов, чтобы код был предсказуемым и легко поддерживаемым.

BEM расшифровывается как:
• B - Block (Блок)
• E - Element (Элемент)
• M - Modifier (Модификатор)

СИНТАКСИС:

.block { }              /* блок */
.block__element { }     /* элемент блока */
.block--modifier { }    /* модификатор блока */
.block__element--modifier { } /* модификатор элемента */

ОБЪЯСНЕНИЕ:

BLOCK (Блок) - это независимый, переиспользуемый компонент.
Примеры: .card, .button, .navbar, .modal

ELEMENT (Элемент) - это часть блока, которая не может существовать отдельно.
Она зависит от блока. Отделяется двойным подчеркиванием __.
Примеры: .card__title, .card__image, .button__text

MODIFIER (Модификатор) - это вариант блока или элемента.
Изменяет внешний вид или поведение. Отделяется двойной дефисом --.
Примеры: .button--large, .button--primary, .card--featured

РЕАЛЬНЫЙ ПРИМЕР:

Представьте карточку товара:

HTML:
<div class="product-card">
  <img class="product-card__image" src="...">
  <h2 class="product-card__title">Название товара</h2>
  <p class="product-card__description">Описание...</p>
  <button class="product-card__button product-card__button--primary">
    Купить
  </button>
</div>

CSS:
/* Блок - основной стиль карточки */
.product-card {
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  max-width: 300px;
}

/* Элементы - части карточки */
.product-card__image {
  width: 100%;
  height: 200px;
  object-fit: cover;
  border-radius: 4px;
}

.product-card__title {
  font-size: 18px;
  margin: 12px 0 8px;
  color: #333;
}

.product-card__description {
  color: #666;
  font-size: 14px;
  margin-bottom: 16px;
}

.product-card__button {
  width: 100%;
  padding: 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  background: #ccc;
  color: #333;
}

/* Модификатор - вариант кнопки (первичный цвет) */
.product-card__button--primary {
  background: #3498db;
  color: white;
}

/* Модификатор - увеличенная кнопка */
.product-card__button--large {
  padding: 14px;
  font-size: 18px;
}

ДРУГОЙ ПРИМЕР - НАВИГАЦИЯ:

HTML:
<nav class="navbar">
  <ul class="navbar__menu">
    <li class="navbar__item">
      <a class="navbar__link" href="/">Главная</a>
    </li>
    <li class="navbar__item">
      <a class="navbar__link navbar__link--active" href="/about">О нас</a>
    </li>
    <li class="navbar__item">
      <a class="navbar__link" href="/contact">Контакты</a>
    </li>
  </ul>
</nav>

CSS:
.navbar {
  background: #333;
  padding: 16px;
}

.navbar__menu {
  list-style: none;
  display: flex;
  gap: 20px;
}

.navbar__item {
  /* стили для элемента */
}

.navbar__link {
  color: white;
  text-decoration: none;
  padding: 8px 0;
}

.navbar__link--active {
  color: #3498db;
  border-bottom: 2px solid #3498db;
}

ПРЕИМУЩЕСТВА BEM:

1. ПОНЯТНОСТЬ - просто посмотрев на название класса, вы поймете его назначение
2. МОДУЛЬНОСТЬ - каждый компонент независим и переиспользуем
3. МАСШТАБИРУЕМОСТЬ - легко добавить новые модификаторы и элементы
4. КОНФЛИКТЫ ИМЕН - вероятность совпадения имен классов снижается
5. КОМАНДНАЯ РАБОТА - все разработчики используют одну систему именования

ПРАВИЛА BEM:

1. Используйте только буквы, цифры и дефисы
2. Элемент не может содержать элемент (не пишите .block__element__element)
3. Модификатор - это всегда добавление, а не замена
4. Один класс для одного "смысла"

НЕПРАВИЛЬНО:
.card__image__wrapper { } /* вложенные элементы */
<img class="card__image--large"> <!-- модификатор вместо класса -->

ПРАВИЛЬНО:
.card__image { }
<img class="card__image card__image--large">

КОГДА ИСПОЛЬЗОВАТЬ BEM:

BEM идеален когда:
• Работаете в команде
• Проект большой и будет долго поддерживаться
• Много переиспользуемых компонентов
• Хотите избежать конфликтов стилей

================================================================================