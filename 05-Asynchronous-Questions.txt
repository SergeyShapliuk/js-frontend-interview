================================================================================
РАЗДЕЛ 5: АСИНХРОННОЕ ПРОГРАММИРОВАНИЕ
================================================================================

ВОПРОС 1: Что такое асинхронное программирование и зачем оно нужно?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Асинхронное программирование - это способ написания кода, который позволяет
программе продолжать работать, пока ждет результата долгой операции
(например, загрузка данных с сервера).

СИНХРОННЫЙ КОД (обычный способ):

Код выполняется строка за строкой, одна строка ждет завершения предыдущей:

function getData() {
  console.log("Начало загрузки...");
  
  // представьте, что это долгая операция (2 секунды)
  let data = loadDataFromServer();  // программа ЖДЕТ тут 2 секунды
  
  console.log("Данные получены: " + data);
  console.log("Готово!");
}

getData();

Результат (все выполняется подряд):
Начало загрузки...
[ждет 2 секунды]
Данные получены: {...}
Готово!

Проблема: пока программа ждет данных, она не может делать ничего другого.
Окно браузера "зависает".

АСИНХРОННЫЙ КОД (с обратным вызовом):

Код выполняется не ждя результата долгой операции:

function getData(callback) {
  console.log("Начало загрузки...");
  
  loadDataFromServerAsync(function(data) {
    console.log("Данные получены: " + data);
    callback(data);
  });
  
  console.log("Загрузка в процессе...");
}

getData(function(data) {
  console.log("Готово! Получены данные: " + data);
});

Результат (асинхронное выполнение):
Начало загрузки...
Загрузка в процессе...
[ждет 2 секунды в фоне]
Данные получены: {...}
Готово! Получены данные: {...}

Преимущество: программа не блокируется, может делать другие дела.

КОГДА НУЖНА АСИНХРОННОСТЬ:

• Загрузка данных с сервера (fetch, AJAX)
• Таймеры (setTimeout, setInterval)
• Работа с файлами
• Базы данных
• Любые долгие операции

В браузере асинхронность особенно важна, потому что блокировка означает
зависание интерфейса.

СПОСОБЫ РЕАЛИЗАЦИИ АСИНХРОННОСТИ:

1. Колбеки (callback) - старый способ
2. Промисы (Promises) - современный способ
3. async/await - самый удобный способ

================================================================================

ВОПРОС 2: Что такое промисы (Promises) и как их использовать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Промис - это объект, который представляет результат асинхронной операции.
Это результат может быть выполнен (resolved) или отклонен (rejected).

СОСТОЯНИЯ ПРОМИСА:

1. PENDING (ожидание) - промис создан, но результат еще неизвестен
2. FULFILLED (выполнено) - операция успешно завершена
3. REJECTED (отклонено) - произошла ошибка

После того как промис перейдет в состояние FULFILLED или REJECTED,
его состояние больше не изменится.

СОЗДАНИЕ ПРОМИСА:

let promise = new Promise(function(resolve, reject) {
  // resolve - функция для выполнения промиса (успех)
  // reject - функция для отклонения промиса (ошибка)
});

ПРОСТОЙ ПРИМЕР:

function loadData() {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      let data = { name: "Иван", age: 25 };
      resolve(data);  // промис успешно выполнен
    }, 2000);  // ждем 2 секунды
  });
}

// Использование промиса:
loadData().then(function(data) {
  console.log("Данные получены: " + data.name);
});

ОБРАБОТКА РЕЗУЛЬТАТА - then():

Promise имеет метод then(), который вызывается когда промис выполнен:

let promise = new Promise(function(resolve, reject) {
  resolve("Успех!");
});

promise.then(function(result) {
  console.log(result);  // "Успех!"
});

ОБРАБОТКА ОШИБОК - catch():

let promise = new Promise(function(resolve, reject) {
  reject("Ошибка!");
});

promise.then(function(result) {
  console.log(result);
}).catch(function(error) {
  console.log("Ошибка: " + error);  // "Ошибка: Ошибка!"
});

или проще:

promise.catch(function(error) {
  console.log("Ошибка: " + error);
});

ПРАКТИЧЕСКИЙ ПРИМЕР - Загрузка данных:

function fetchUserData(userId) {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      if (userId > 0) {
        let user = { id: userId, name: "Иван" };
        resolve(user);  // успех
      } else {
        reject("Неверный ID пользователя");  // ошибка
      }
    }, 1000);
  });
}

// Использование:
fetchUserData(1)
  .then(function(user) {
    console.log("Пользователь получен: " + user.name);
  })
  .catch(function(error) {
    console.log("Ошибка: " + error);
  });

ЦЕПОЧКА ПРОМИСОВ:

then() также возвращает промис, поэтому можно цепить вызовы:

fetchUserData(1)
  .then(function(user) {
    console.log("Получен пользователь: " + user.name);
    return user.id;  // return автоматически оборачивается в промис
  })
  .then(function(userId) {
    console.log("ID пользователя: " + userId);
    return userId * 2;
  })
  .then(function(result) {
    console.log("Результат: " + result);
  })
  .catch(function(error) {
    console.log("Ошибка: " + error);
  });

Результат:
Получен пользователь: Иван
ID пользователя: 1
Результат: 2

PROMISE.ALL - Ждать несколько промисов:

let promise1 = Promise.resolve(1);
let promise2 = Promise.resolve(2);
let promise3 = new Promise(function(resolve) {
  setTimeout(function() {
    resolve(3);
  }, 1000);
});

Promise.all([promise1, promise2, promise3])
  .then(function(results) {
    console.log(results);  // [1, 2, 3]
  });

PROMISE.RACE - Первый выполненный промис:

let promise1 = new Promise(function(resolve) {
  setTimeout(function() { resolve("Первый"); }, 1000);
});

let promise2 = new Promise(function(resolve) {
  setTimeout(function() { resolve("Второй"); }, 500);
});

Promise.race([promise1, promise2])
  .then(function(result) {
    console.log(result);  // "Второй" (быстрее)
  });

================================================================================

ВОПРОС 3: Что такое async/await и как они упрощают асинхронный код?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

async/await - это синтаксический сахар над промисами, который делает
асинхронный код похожим на синхронный. Это намного удобнее чем then().

ОСНОВНОЕ ПОНЯТИЕ:

• async - ключевое слово перед функцией, которая содержит асинхронный код
• await - ключевое слово, которое ждет выполнения промиса

ПРОСТОЙ ПРИМЕР:

С промисами (then):

function getData() {
  return fetch('/api/users')
    .then(response => response.json())
    .then(data => {
      console.log(data);
      return data;
    });
}

С async/await:

async function getData() {
  let response = await fetch('/api/users');
  let data = await response.json();
  console.log(data);
  return data;
}

Второй вариант намного чище и понятнее!

СИНТАКСИС:

async function functionName() {
  try {
    let result = await someAsyncOperation();
    console.log(result);
  } catch (error) {
    console.log("Ошибка: " + error);
  }
}

или стрелочная функция:

const functionName = async () => {
  try {
    let result = await someAsyncOperation();
    console.log(result);
  } catch (error) {
    console.log("Ошибка: " + error);
  }
};

РЕАЛЬНЫЙ ПРИМЕР - Загрузка данных пользователя:

async function loadUserData(userId) {
  try {
    let response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error("Пользователь не найден");
    }
    
    let user = await response.json();
    console.log("Пользователь: " + user.name);
    return user;
  } catch (error) {
    console.log("Ошибка: " + error.message);
  }
}

// Использование:
loadUserData(1);

ОБЪЯСНЕНИЕ:

1. async делает функцию асинхронной и автоматически возвращает промис
2. await останавливает выполнение и ждет результат промиса
3. try/catch ловит ошибки (вместо .catch())

НЕСКОЛЬКО АСИНХРОННЫХ ОПЕРАЦИЙ:

НЕПРАВИЛЬНО (медленно - операции выполняются последовательно):

async function getData() {
  let user = await fetchUser();      // ждет 1 секунду
  let posts = await fetchPosts();    // ждет еще 1 секунду
  // всего 2 секунды
  
  return { user, posts };
}

ПРАВИЛЬНО (быстро - операции выполняются параллельно):

async function getData() {
  let [user, posts] = await Promise.all([
    fetchUser(),
    fetchPosts()
  ]);
  // всего 1 секунда
  
  return { user, posts };
}

ПРЕОБРАЗОВАНИЕ ПРОМИСА В ASYNC/AWAIT:

Промис:
function fetchData() {
  return fetch('/api/data')
    .then(response => response.json())
    .then(data => {
      return data;
    })
    .catch(error => {
      console.log("Ошибка: " + error);
    });
}

Async/await:
async function fetchData() {
  try {
    let response = await fetch('/api/data');
    let data = await response.json();
    return data;
  } catch (error) {
    console.log("Ошибка: " + error);
  }
}

ПОЛНЫЙ ПРИМЕР - API запрос:

async function searchUsers(query) {
  try {
    // 1. Отправляем запрос
    let response = await fetch(`https://api.github.com/search/users?q=${query}`);
    
    // 2. Проверяем статус
    if (!response.ok) {
      throw new Error("Запрос не удался");
    }
    
    // 3. Парсим JSON
    let data = await response.json();
    
    // 4. Выводим результаты
    console.log("Найдено пользователей: " + data.items.length);
    return data.items;
    
  } catch (error) {
    console.log("Ошибка: " + error.message);
    return [];
  }
}

// Использование:
let results = await searchUsers("john");

================================================================================