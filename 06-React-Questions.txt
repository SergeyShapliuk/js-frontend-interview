================================================================================
РАЗДЕЛ 6: REACT И СОВРЕМЕННЫЕ БИБЛИОТЕКИ
================================================================================

ВОПРОС 1: Что такое React и почему его используют?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

React - это JavaScript библиотека для создания пользовательских интерфейсов (UI).
Она разработана Facebook и используется для с��здания быстрых, интерактивных
веб-приложений.

ЧТО ДЕЛАЕТ REACT?

React помогает управлять состоянием (data) и связывает его с интерфейсом.
Когда состояние меняется, интерфейс автоматически обновляется.

ПРОБЛЕМА БЕЗ REACT:

Без React, если нужно обновить интерфейс, вы должны вручну��:
1. Найти элементы в DOM
2. Изменить их содержимое
3. Добавить/удалить классы
4. Обработать события

Это быстро становится сложным и ошибочным.

ПРИМЕР БЕЗ REACT:

HTML:
<div id="app">
  <p id="counter">0</p>
  <button id="btn">Увеличить</button>
</div>

JavaScript:
let count = 0;
let counterEl = document.getElementById("counter");
let button = document.getElementById("btn");

button.addEventListener("click", function() {
  count++;
  counterEl.textContent = count;  // вручную обновляем DOM
});

Проблемы:
• Нужно вручную находить элементы
• Нужно вручную обновлять DOM
• Сложно управлять состоянием при большом коде
• Легко сделать ошибку

РЕШЕНИЕ С REACT:

React с помощью JSX (синтаксис похож на HTML):

import React, { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);  // состояние
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}

Преимущества:
• Состояние (count) хранится в одном месте
• JSX выглядит как HTML, понятнее
• React автоматически обновляет DOM когда состояние меняется
• Меньше кода, меньше ошибок

КЛЮЧЕВЫЕ КОНЦЕПЦИИ REACT:

1. КОМПОНЕНТЫ - переиспользуемые части интерфейса

Функциональный компонент (современный способ):

function Greeting() {
  return <h1>Привет, мир!</h1>;
}

Класс компонент (старый способ):

class Greeting extends React.Component {
  render() {
    return <h1>Привет, мир!</h1>;
  }
}

2. JSX - синтаксис, похожий на HTML, но в JavaScript

let greeting = <h1>Привет!</h1>;

Это преобразуется в:

let greeting = React.createElement('h1', null, 'Привет!');

3. СВОЙСТВА (props) - передача данных в компонент

function Greeting(props) {
  return <h1>Привет, {props.name}!</h1>;
}

// Использование:
<Greeting name="Иван" />  // выведет "Привет, Иван!"

4. СОСТОЯНИЕ (state) - данные, которые меняются

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}

ЗАЧЕМ НУЖЕН REACT?

1. ПЕРЕИСПОЛЬЗУЕМОСТЬ - создаете компоненты один раз, используете везде
2. ПРОИЗВОДИТЕЛЬНОСТЬ - React оптимизирует обновления DOM (Virtual DOM)
3. МАСШТАБИРУЕМОСТЬ - легче управлять большим приложением
4. ПОДДЕРЖИВАЕМОСТЬ - код понятнее и легче менять
5. БОЛЬШОЕ СООБЩЕСТВО - много готовых библиотек и решений

КОГДА ИСПОЛЬЗОВАТЬ REACT:

• Интерактивные веб-приложения (SPA - Single Page Applications)
• Приложения с частыми обновлениями интерфейса
• Проекты с много компонентов и состояния
• Когда нужна переиспользуемость компонентов

КОГДА REACT НЕ НУЖЕН:

• Простые статические сайты (достаточно чистого HTML)
• Маленькие проекты без интерактивности
• Когда загрузка JavaScript критична (React добавляет вес)

================================================================================

ВОПРОС 2: Что такое хуки (hooks) и как их использовать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Хуки - это функции, которые позволяют вам "подцепиться" к функциям React
(состояние, эффекты и т.д.). Они появились в React 16.8 и изменили способ
написания компонентов.

До хуков состояние можно было использовать только в классовых компонентах.
С хуками можно использовать состояние в функциональных компонентах.

ОСНОВНЫЕ ХУКИ:

1. useState - для управления состоянием

Синтаксис:
const [value, setValue] = useState(initialValue);

• value - текущее значение состояния
• setValue - функция для изменения значения
• initialValue - начальное значение

Пример - счетчик:

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
      <button onClick={() => setCount(count - 1)}>
        Уменьшить
      </button>
    </div>
  );
}

Как это работает:
1. useState(0) создает состояние с начальным значением 0
2. count содержит текущее значение (изначально 0)
3. setCount - функция для изменения count
4. При клике на кнопку setCount изменяет count и компонент перерисовывается

НЕСКОЛЬКО СОСТОЯНИЙ:

function LoginForm() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [errors, setErrors] = useState([]);
  
  return (
    <form>
      <input
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Имя пользователя"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Пароль"
      />
      {errors.length > 0 && (
        <ul>
          {errors.map(error => <li key={error}>{error}</li>)}
        </ul>
      )}
    </form>
  );
}

2. useEffect - для побочных эффектов

Побочные эффекты - это операции вне рендеринга компонента:
• Загрузка данных с сервера
• Установка таймеров
• Подписка на события

Синтаксис:
useEffect(() => {
  // код побочного эффекта
  return () => {
    // код очистки (опционально)
  };
}, [dependencies]);

ПРИМЕР 1: Загрузка данных при монтировании компонента

function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Загружаем данные пользователя
    fetch('/api/user')
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, []);  // пустой массив = выполнить один раз при монтировании
  
  if (loading) return <p>Загрузка...</p>;
  
  return <h1>Привет, {user.name}!</h1>;
}

ПРИМЕР 2: Таймер с очисткой

function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
    
    // Очистка: останавливаем таймер при размонтировании
    return () => clearInterval(interval);
  }, []);
  
  return <p>Прошло {seconds} секунд</p>;
}

ПРИМЕР 3: Зависимости

function SearchUsers(searchQuery) {
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    // Загружаем результаты только если searchQuery изменился
    fetch(`/api/search?q=${searchQuery}`)
      .then(response => response.json())
      .then(data => setResults(data));
  }, [searchQuery]);  // зависимость: searchQuery
  
  return (
    <ul>
      {results.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

МАССИВ ЗАВИСИМОСТЕЙ:

• [] (пусто) - выполнить один раз при монтировании
• [value1, value2] - выполнить при изменении value1 или value2
• вообще не указывать - выполнить при каждом рендеринге (не рекомендуется)

3. useContext - для передачи данных через компоненты

Без useContext нужно передавать props через много слоев компонентов (prop drilling):

function App() {
  return <Parent theme="dark" />;
}

function Parent({ theme }) {
  return <Child theme={theme} />;
}

function Child({ theme }) {
  return <Button theme={theme} />;
}

С useContext можно избежать этого:

// Создаем контекст
const ThemeContext = React.createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Parent />
    </ThemeContext.Provider>
  );
}

function Parent() {
  return <Child />;
}

function Child() {
  return <Button />;
}

function Button() {
  const theme = useContext(ThemeContext);  // получаем значение напрямую
  return <button className={theme}>Кнопка</button>;
}

4. useReducer - для сложного состояния

Если у вас много состояний которые взаимосвязаны, можно использовать useReducer:

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  
  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>
        Увеличить
      </button>
    </div>
  );
}

function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

ПРАВИЛА ИСПОЛЬЗОВАНИЯ ХУКОВ:

1. Используйте хуки только в функциональных компонентах React
2. Вызывайте хуки только на верхнем уровне функции (не в циклах или условиях)
3. Используйте ESLint плагин для проверки правил

НЕПРАВИЛЬНО:

function Bad() {
  if (someCondition) {
    const [state, setState] = useState(0);  // ошибка!
  }
}

ПРАВИЛЬНО:

function Good() {
  const [state, setState] = useState(0);
  
  if (someCondition) {
    // используем state
  }
}

================================================================================

ВОПРОС 3: Что такое пропсы (props) и как передавать данные в компоненты?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Пропсы (props) - это способ передачи данных от родительского компонента
к дочернему компоненту. Это как параметры функции.

ПРОСТОЙ ПРИМЕР:

function Greeting(props) {
  return <h1>Привет, {props.name}!</h1>;
}

// Использование:
<Greeting name="Иван" />  // выведет "Привет, Иван!"

ОБЪЯСНЕНИЕ:

1. name="Иван" - передаем проп name со значением "Иван"
2. props - объект, который содержит {name: "Иван"}
3. props.name - получаем значение проппа

НЕСКОЛЬКО ПРОПСОВ:

function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>Возраст: {props.age}</p>
      <p>Город: {props.city}</p>
    </div>
  );
}

// Использование:
<UserCard name="Иван" age={25} city="Москва" />

Результат:
Иван
Возраст: 25
Город: Москва

ДЕСТРУКТУРИЗАЦИЯ ПРОПСОВ:

Вместо props.name, props.age можно деструктурировать:

function UserCard({ name, age, city }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Возраст: {age}</p>
      <p>Город: {city}</p>
    </div>
  );
}

Это более компактно и читаемо.

ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ:

Вы можете установить значения по умолчанию для пропсов:

function Button({ label = "Нажми", color = "blue" }) {
  return <button className={color}>{label}</button>;
}

// Использование:
<Button />  // используются значения по умолчанию
<Button label="Отправить" color="red" />  // переопределяем

ПЕРЕДАЧА ОБЪЕКТОВ И МАССИВОВ:

function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Использование:
const users = [
  { id: 1, name: "Иван" },
  { id: 2, name: "Мария" }
];

<UserList users={users} />

ПЕРЕДАЧА ФУНКЦИЙ:

function Button({ onClick, label }) {
  return <button onClick={onClick}>{label}</button>;
}

// Использование:
<Button 
  label="Сохранить"
  onClick={() => console.log("Сохранено!")}
/>

ОТЛИЧИЕ: PROPS vs STATE

PROPS:
• Передаются от родителя к дочернему компоненту
• Неизменяемы (read-only)
• Используются для передачи данных

STATE:
• Локальные для компонента
• Изменяемы (через setState/setters)
• Используются для управления поведением компонента

Пример:

function Parent() {
  const [count, setCount] = useState(0);  // state
  
  return (
    <div>
      <Child count={count} />  {/* передаем как проп */}
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}

function Child({ count }) {  // получаем как проп
  return <p>Счетчик: {count}</p>;
}

ПРОП DRILLING ПРОБЛЕМА:

Если нужно передать данные глубоко в компоненты, нужно передавать через все уровни:

function App() {
  const user = { name: "Иван" };
  return <Level1 user={user} />;
}

function Level1({ user }) {
  return <Level2 user={user} />;
}

function Level2({ user }) {
  return <Level3 user={user} />;
}

function Level3({ user }) {
  return <h1>{user.name}</h1>;
}

РЕШЕНИЕ: использовать Context API (useContext)

const UserContext = React.createContext();

function App() {
  const user = { name: "Иван" };
  return (
    <UserContext.Provider value={user}>
      <Level1 />
    </UserContext.Provider>
  );
}

function Level1() {
  return <Level2 />;
}

function Level2() {
  return <Level3 />;
}

function Level3() {
  const user = useContext(UserContext);
  return <h1>{user.name}</h1>;
}

================================================================================

ВОПРОС 4: Что такое условный рендеринг и как его реализовать?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Условный рендеринг - это отображение разных элементов в зависимости от условия.

СПОСОБ 1: if/else в функции

function LoginStatus({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Добро пожаловать обратно!</h1>;
  } else {
    return <h1>Пожалуйста, войдите</h1>;
  }
}

// Использование:
<LoginStatus isLoggedIn={true} />    // выведет "Добро пожаловать обратно!"
<LoginStatus isLoggedIn={false} />   // выведет "Пожалуйста, войдите"

СПОСОБ 2: Тернарный оператор

function LoginStatus({ isLoggedIn }) {
  return (
    <h1>
      {isLoggedIn ? "Добро пожаловать обратно!" : "Пожалуйста, войдите"}
    </h1>
  );
}

СПОСОБ 3: Логический оператор &&

Используется когда нужно отобразить что-то если условие true, иначе ничего:

function Notifications({ count }) {
  return (
    <div>
      {count > 0 && <span>У вас {count} новых сообщений</span>}
    </div>
  );
}

// Если count > 0, покажет сообщение
// Если count = 0, покажет ничего

��ПОСОБ 4: switch

function UserRole({ role }) {
  switch (role) {
    case 'admin':
      return <h1>Панель администратора</h1>;
    case 'user':
      return <h1>Кабинет пользователя</h1>;
    case 'guest':
      return <h1>Гостевой режим</h1>;
    default:
      return <h1>Неизвестная роль</h1>;
  }
}

ПРАКТИЧЕСКИЙ ПРИМЕР - Загрузка данных:

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);
  
  // Условный рендеринг
  if (loading) {
    return <p>Загрузка...</p>;
  }
  
  if (error) {
    return <p>Ошибка: {error}</p>;
  }
  
  if (!user) {
    return <p>Пользователь не найден</p>;
  }
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

================================================================================

ВОПРОС 5: Что такое список (list) и как его рендерить в React?
────────────────────────────────────────────────────────────────────────────────

ОТВЕТ:

Список - это отображение массива данных как набора элементов.
В React используется метод map() для создания элементов из массива.

ПРОСТОЙ ПРИМЕР:

function FruitList() {
  const fruits = ["Яблоко", "Груша", "Апельсин"];
  
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}

Результат:
• Яблоко
• Груша
• Апельсин

ОБЪЯСНЕНИЕ:

1. fruits.map() преобразует каждый элемент массива в JSX элемент
2. key={index} - уникальный идентификатор для каждого элемента (важно!)
3. Метод map вызывается для каждого элемента массива

ВАЖНО: ВСЕГДА ИСПОЛЬЗУЙТЕ УНИКАЛЬНЫЙ KEY!

НЕПРАВИЛЬНО (использование index как key):

{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}

Проблемы:
• Если элементы переупорядочиваются, индексы меняются
• React может не правильно обновить элементы
• Может быть потеря состояния

ПРАВИЛЬНО (использование уникального id):

{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}

ПРИМЕР С ОБЪЕКТАМИ:

function UserList() {
  const users = [
    { id: 1, name: "Иван", email: "ivan@example.com" },
    { id: 2, name: "Мария", email: "maria@example.com" },
    { id: 3, name: "Петр", email: "petr@example.com" }
  ];
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          <strong>{user.name}</strong> - {user.email}
        </li>
      ))}
    </ul>
  );
}

ОТДЕЛЬНЫЙ КОМПОНЕНТ ДЛЯ ЭЛЕМЕНТА СПИСКА:

Лучше создать отдельный компонент для каждого элемента:

function UserItem({ id, name, email }) {
  return (
    <li>
      <strong>{name}</strong> - {email}
    </li>
  );
}

function UserList() {
  const users = [
    { id: 1, name: "Иван", email: "ivan@example.com" },
    { id: 2, name: "Мария", email: "maria@example.com" }
  ];
  
  return (
    <ul>
      {users.map(user => (
        <UserItem key={user.id} {...user} />
      ))}
    </ul>
  );
}

ПРИМЕР С ФИЛЬТРОМ И ПОИСКОМ:

function SearchableUserList() {
  const allUsers = [
    { id: 1, name: "Иван" },
    { id: 2, name: "Мария" },
    { id: 3, name: "Петр" }
  ];
  
  const [searchQuery, setSearchQuery] = useState("");
  
  // Фильтруем пользователей
  const filteredUsers = allUsers.filter(user =>
    user.name.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  return (
    <div>
      <input
        placeholder="Поиск..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
      />
      
      <ul>
        {filteredUsers.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      
      {filteredUsers.length === 0 && (
        <p>Пользователи не найдены</p>
      )}
    </div>
  );
}

================================================================================